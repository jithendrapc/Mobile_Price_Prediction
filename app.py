# -*- coding: utf-8 -*-
"""Mobile_Price_Prediction_2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/10HdiQmb7sO3SpLDzXCwu-IQXEhDoVTlJ
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.impute import SimpleImputer
from sklearn.experimental import enable_iterative_imputer
from sklearn.impute import IterativeImputer
import warnings
warnings.filterwarnings("ignore")
df=pd.read_csv('cleaneddata.csv',index_col=False)
d=pd.read_csv('smartphones.csv')
col=df.columns
col

df.drop(columns=[col[0],col[19]],inplace=True)
df.columns

df['p_cam'].fillna(0,inplace=True)
df['s_cam'].fillna(0,inplace=True)
df['t_cam'].fillna(0,inplace=True)
df['f_cam'].fillna(df.f_cam.mean(),inplace=True)
df.info()

df.core=np.where(df['core'].str.contains('GHz'),np.NaN,df['core'])
df.core=df.core.replace(['Octa','Hexa','Quad','Dual'],[8,6,4,2])
df.core.value_counts()

#df=df[~df['proc_type'].str.contains('Dual')]
df=df[~df['proc_type'].isin(['Dual','Octa','Quad'])]
df.proc_type.unique()





df.proc_type=np.where(df['proc_type'].str.contains('Apple'),'Bionic',df['proc_type'])
df.proc_type=np.where(df['proc_type'].str.contains('A13'),'Bionic',df['proc_type'])
df.proc_type=np.where(df['proc_type'].str.contains('Qualcomm') | df['proc_type'].str.contains('Sanpdragon'),'Snapdragon',df['proc_type'])
df.proc_type=np.where(df['proc_type'].str.contains('SC986'),'Unisoc',df['proc_type'])
df.proc_type=np.where(df['proc_type'].str.contains('Samsung') | df['proc_type'].str.contains('28'),'Exynos',df['proc_type'])
df.proc_type.value_counts()

df.notch=df.notch.replace(['Dual','Small','Large'],['Punch','Notch','Notch'])
df.notch.unique()

df.os_type=np.where(df['os_type'].str.contains('Memory'),np.NaN,df['os_type'])
df.os_type=np.where(df['os_type'].str.contains('Bluetooth'),np.NaN,df['os_type'])
df.os_type.unique()

df=df[df.price < 500000]
df

df.info()

SEED = 42
TARGET = 'price'
FEATURES = df.columns.drop(TARGET)

NUMERICAL = df[FEATURES].select_dtypes('number').columns
print(NUMERICAL)
print(f"Numerical features: {', '.join(NUMERICAL)}")

CATEGORICAL = pd.Index(np.setdiff1d(FEATURES, NUMERICAL))
print(CATEGORICAL)
print(f"Categorical features: {', '.join(CATEGORICAL)}")

X=df.drop(columns=TARGET)
y=df[TARGET]

X.isna().sum()

from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.svm import SVR
from sklearn.ensemble import RandomForestRegressor,VotingRegressor,ExtraTreesRegressor
from sklearn.ensemble import GradientBoostingRegressor
from sklearn.ensemble import AdaBoostRegressor
from xgboost import XGBRegressor
from lightgbm import LGBMRegressor
from sklearn.neighbors import KNeighborsRegressor
from sklearn.impute import SimpleImputer
from sklearn.experimental import enable_iterative_imputer
from sklearn.impute import IterativeImputer
from sklearn.preprocessing import OneHotEncoder,MinMaxScaler
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline
from sklearn.metrics import r2_score
from tqdm import tqdm
from sklearn.model_selection import GridSearchCV
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=SEED)

numerical_pipe = Pipeline([
    ('imputer',IterativeImputer()),
    ('imputer1', SimpleImputer(strategy='mean',fill_value=np.NaN)),
    ('scaler', MinMaxScaler())
])

categorical_pipe = Pipeline([

    ('imputer1', SimpleImputer(strategy='most_frequent', fill_value=np.NaN)),
    ('encoder', OneHotEncoder(drop='first', handle_unknown='ignore', sparse=False))
])

preprocessors = ColumnTransformer(transformers=[
    ('num', numerical_pipe, NUMERICAL),
    ('cat', categorical_pipe, CATEGORICAL)
])

pipe1 = Pipeline([
    ('preprocessors', preprocessors),
    ('model', LinearRegression())
])

pipe1.fit(X_train, y_train)
y_pred=pipe1.predict(X_test)

r2_score(y_test,y_pred)







from sklearn.ensemble import ExtraTreesRegressor
from tqdm import tqdm

regressor = ExtraTreesRegressor(bootstrap=False, ccp_alpha=0.0, criterion='friedman_mse',
                    max_depth=None, max_features='auto', max_leaf_nodes=None,
                    max_samples=None, min_impurity_decrease=0.0, min_samples_leaf=1,
                    min_samples_split=2, min_weight_fraction_leaf=0.0,
                    n_estimators=100, n_jobs=-1, oob_score=False,
                    random_state=123, verbose=0, warm_start=False)
scores=[]
for i in tqdm(range(1000)):
    X_train,X_test,y_train,y_test=train_test_split(X,y,test_size=0.2,random_state=i)
    lr=LinearRegression()
    pipe2 = Pipeline([
    ('preprocessors', preprocessors),
    ('model', regressor)
    ])
    pipe2.fit(X_train,y_train)
    y_pred=pipe2.predict(X_test)
    scores.append(r2_score(y_test,y_pred))

X_train,X_test,y_train,y_test=train_test_split(X,y,test_size=0.2,random_state=np.argmax(scores))
pipe2= Pipeline([
    ('preprocessors', preprocessors),
    ('model', regressor)
])
pipe2.fit(X_train,y_train)
y_pred=pipe2.predict(X_test)
r2_score(y_test,y_pred)

import pickle
pickle.dump(pipe2,open('ExtratreeRegressorModel.pkl','wb'))



model1 = RandomForestRegressor()
model2 = LGBMRegressor()
model3 = XGBRegressor()
model4 = ExtraTreesRegressor(bootstrap=False, ccp_alpha=0.0, criterion='friedman_mse',
                    max_depth=None, max_features='auto', max_leaf_nodes=None,
                    max_samples=None, min_impurity_decrease=0.0, min_samples_leaf=1,
                    min_samples_split=2, min_weight_fraction_leaf=0.0,
                    n_estimators=100, n_jobs=-1, oob_score=False,
                    random_state=42, verbose=0, warm_start=False)
model5 = AdaBoostRegressor()
model6 = GradientBoostingRegressor()
model7 = SVR()
model8 = KNeighborsRegressor()

vc = VotingRegressor(estimators=[
          ('1',model1),('2',model2),('3',model3),('4',model4),('5',model5),('6',model6),('7',model7),('8',model8)])
vc = VotingRegressor(estimators=[
          ('1',model1),('4',model4),('6',model6)])

X=df.drop(columns=TARGET)
y=df[TARGET]
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

pipe1 = Pipeline([
    ('preprocessors', preprocessors),
    ('model', vc)
])

pipe1.fit(X_train, y_train)
y_pred=pipe1.predict(X_test)
r2_score(y_test,y_pred)



### Extratreeregressor works well.

!pip install gradio

import gradio as gr

#Des="Allowed values for features:\nRating:"+'choose value any from '+str(df.rating.min())+' to '+str(df.rating.max())+'/nBattery Capacity:'+'choose value any from '+str(df.bat_cap.min())+' to '+str(df.bat_cap.max())+'\nBattery speed:'+'choose value any from  '+str(df.bat_speed.min())+' to '+str(df.bat_speed.max())"

inputs = [
    gr.inputs.Dropdown(list(df.Brand.unique()),label='Brand', default='Samsung'),
    gr.Markdown('Choose rating value between '+str(df.rating.min())+' and '+str(df.rating.max())),
    gr.inputs.Number(label='Rating in 0 to 100 scale', default=int(df.rating.mean())),
    gr.Markdown('Choose Battery Capacity value between '+str(df.bat_cap.min())+' and '+str(df.bat_cap.max())),
    gr.inputs.Number(label='Battery Capacity in mAH', default=int(df.bat_cap.mean())),
    gr.Markdown('Choose Battery Speed value between '+str(df.bat_speed.min())+' and '+str(df.bat_speed.max())),
    gr.inputs.Number(label='Battery charger Speed in W', default=int(df.bat_speed.mean())),
    gr.Markdown('Choose RAM value between '+str(df.ram.min())+' and '+str(df.ram.max())),
    gr.inputs.Number(label='Ram in GB', default=int(df.ram.mean())),
    gr.Markdown('Choose ROM value between '+str(df.rom.min())+' and '+str(df.rom.max())),
    gr.inputs.Number(label='Rom in GB', default=int(df.rom.mean())),
    gr.inputs.Dropdown(list(df.os_ver.unique()),label='OS Version', default='10'),
    gr.inputs.Dropdown(list(df.os_type.unique()),label='OS Type', default='Android'),
    gr.Markdown('Choose Screen Size value between '+str(df.inches.min())+' and '+str(df.inches.max())),
    gr.inputs.Number(label='Screen Size in Inches', default=df.inches.mean()),
    gr.Markdown('Choose Screen Refresh Rate value between '+str(df.refresh_rate.min())+' and '+str(df.refresh_rate.max())),
    gr.inputs.Number(label='Refresh Rate in Hz', default=int(df.refresh_rate.mean())),
    gr.inputs.Dropdown(list(df.notch.unique()),label='Notch', default='Punch'),
    gr.Markdown('Choose pixel width and height value between 250 to 3000'),
    gr.inputs.Number(label='pixel_width ', default=1080),
    gr.inputs.Number(label='pixel_height', default=1200),
    gr.Markdown('Choose primary camera value between '+str(df.p_cam.min())+' and '+str(df.p_cam.max())),
    gr.inputs.Number(label='primary_camera in MP', default=int(df.p_cam.mean())),
    gr.Markdown('Choose secondary camera value between '+str(df.s_cam.min())+' and '+str(df.s_cam.max())),
    gr.inputs.Number(label='secondary_camera in MP', default=int(df.s_cam.mean())),
    gr.Markdown('Choose teritiary camera value between '+str(df.t_cam.min())+' and '+str(df.t_cam.max())),
    gr.inputs.Number(label='Teritiary_camera in MP', default=int(df.t_cam.mean())),
    gr.Markdown('Choose front camera value between '+str(df.f_cam.min())+' and '+str(df.f_cam.max())),
    gr.inputs.Number(label='front_camera in MP', default=int(df.f_cam.mean())),
    gr.inputs.Dropdown(list(df.proc_type.unique()),label='Processor', default='Exynos'),
    gr.inputs.Dropdown(list(df.core.unique()),label='No of cores', default='8'),
    gr.Markdown('Choose clock speed in GHz value between '+str(df.ghz.min())+' and '+str(df.ghz.max())),
    gr.inputs.Number(label='Ghz', default=int(df.ghz.mean())),
    gr.inputs.Radio(label='5G',choices=['yes','no'],default='no',type='index'),
    gr.inputs.Radio(label='IR Blaster',choices=['yes','no'],default='no',type='index'),
    gr.inputs.Radio(label='NFC',choices=['yes','no'],default='no',type='index')
]

outputs = [
     gr.outputs.Label(),
     gr.outputs.Label()

]

def predict_price(Brand,t1,rating,t2,bat_cap,t3,bat_speed,t4,ram,t5,rom,os_ver,os_type,t6,inches,t7,refresh_rate,notch,t8,pixel_width,pixel_height,t9,p_cam,t10,s_cam,t11,t_cam,t12,f_cam,proc_type,core,t13,ghz,G5,IR_Blaster,NFC):
  pixel=int(pixel_height)*int(pixel_width)
  data=pd.DataFrame({'Brand':[Brand],'rating':[float(rating)],'bat_cap':[float(bat_cap)],'bat_speed':[float(bat_speed)],'ram':[int(ram)],'rom':[int(rom)],'os_ver':[float(os_ver)],
                     'os_type':[os_type],'inches':[float(inches)],'refresh_rate':[float(refresh_rate)],'notch':[notch],'pixel':[float(pixel)],
                     'p_cam':[float(p_cam)],'s_cam':[float(s_cam)],'t_cam':[float(t_cam)],'f_cam':[float(f_cam)],'proc_type':[proc_type],
                     'core':[float(core)],'ghz':[float(ghz)],'5G':[int(G5)],'IR Blaster':[int(IR_Blaster)],'NFC':[int(NFC)]
                   })
  X_pred=data[data.columns]
  y_pred=pipe2.predict(X_pred)[0]
  #y_pred=pipe1.predict(X_pred)[0]
  return 'Estimated price',y_pred









app = gr.Interface(fn=predict_price,inputs=inputs, outputs=outputs, css="footer {visibility: hidden}", title='Mobile Price Prediction')
app.launch(share=True,debug=True)